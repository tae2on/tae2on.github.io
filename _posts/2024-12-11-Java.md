---
title: "자바 | Java" 
date: 2024-12-11 00:20:24 +0900
achieved: 2024-11-29 17:30:00 +0900
math: true
categories: [Bootcamp, KT Aivle School]
tags: [Bootcamp, KT Aivle School, Python, Jupyter Notebook, Pandas, Java]
---
----------
> KT 에이블스쿨 6기 자바에 진행한 강의 내용 정리한 글입니다. 
{: .prompt-info } 

## **프로그래밍 언어 종류**
컴퓨터와 인간 사이를 연결할 수 있는 매개체이며 컴퓨터에 작업을 시키기 위한 도구 

- 자바(Java): 임베디드, 웹, 안드로이드 소프트웨어(SW) 개발 분야
- C/C++: 하드웨어(HW) 장치 제어 및 임베디드 SW 분야
- C++/C#: 데스크탑 앱 또는 ASP. NET 기반 웹 SW 분야 
- 파이썬(Python): 빅데이터 분석 및 머신러닝 SW 분야 

| 구분  | 컴파일러 언어 | 인터프리터(스크립트) 언어 |
|-------|-----|--------|
| 코드 변환 시점 | 컴파일 타임에 소스 코드를 전체 변환 후 실행 | 런타임에 한 줄씩 바이트코드로 변환 후 실행 |
| 실행 파일 생성 여부   | 실행 파일 생성 | 실행 파일 생성 X |
| 단계 분리 여부  | 컴파일 단계와 실행 단계가 분리   | 인터프리트 단계와 실행 단계 분리 X  |
| 변환 및 실행 방식     | 컴파일은 한 번만 수행     | 코드 실행 시마다 인터프리트 과정 반복 수행 |
| 실행 속도| 코드 실행 시 빠름   | 반복 수행으로 실행 속도가 느림|

### **Java**
**특징**

- 객체 지향성: 모든 것을 객체로 취급하며, 클래스를 통해 객체를 정의
- 플랫폼 독립성: 자바 가상 머신(JVM) 위에서 실행되기 때문에 한번 작성한 코드는 어떤 플랫폼에서도 실행 가능
- 자동 메모리 관리: 가비지 컬렉터를 통해 사용하지 않는 메모리를 자동으로 정리
- 보안성: 실행되기 전 바이트코드를 검증하여 안전성을 확보
- 멀티스레드 지원: 언어 차원에서 멀티스레딩을 지원하여 복잡한 프로그램도 효율적으로 동작 가능 
- 리치 라이브러리: 풍부한 표준 라이브러리와 다양한 오픈 소스 라이브러리가 지원
- 네트워크와 분산 처리 지원: 인터넷 기반의 애플리케이션 개발에 필요한 강력한 네트워킹 기능을 제공
- 동적 로딩(Dynamic Loading): 필요한 시점에 클래스를 동적으로 로딩하여 사용 가능 
    - 자바에서는 CLass.forName(), ClassLoader 등의 메커니즘을 통해 구현 
    - 모든 코드를 프로그램 시작 시 한번에 메모리에 올리지 않고 필요할 때마다 해당 부분만 로드하여 사용
    - 메모리 사용 효율을 높이고 애플리케이션의 시작 시간을 단축시키는 효과 

**개발 과정**

1. 소스 파일 작성(Source File Writing): .java 확장자를 가진 자바 소스 코드 파일 작성
2. 컴파일(Compilation): javac 컴파일러로 소스 파일을 컴파일하여 .class 파일(바이트 코드) 생성
3. 로딩(Loading): 클래스 로더가 .class 파일을 JVM에 로드
4. 링킹(Linking): 검증(Verification), 준비(Preparation), 해석(Resolution) 단계를 거쳐 실행 준비 
5. 초기화 (Initialization): 클래스 변수 초기화 및 정적 블록 실행
6. 실행(Execution): JVM의 인터프리터나 JIT 컴파일러가 바이트코드 실행

#### **JVM & JRE & JDK**

**JVM(Java Virtual Machine)**

- JVM은 자바 소스코드로부터 만들어지는 자바 바이트 코드를 실행할 수 있음
- JVM은 플랫폼에 의존적
    - 리눅스의 JVM과 윈도우즈의 JVM은 다름
- 컴파일된 바이트 코드는 어떤 JVM에서도 동작
- JVM의 역할
    - 바이트 코드를 읽고 검증하고 실행 
    - 실행환경(Runtime Environment)의 규격을 제공 

**JRE(Java Runtime Environment)**

- 컴파일된 자바 프로그램을 실행시킬 수 있는 자바 환경
- JVM이 자바 프로그램을 동작시킬 때 필요한 라이브러리 파일들과 기타 파일들을 가짐
- JRE는 JVM의 실행환경을 구현
- 자바 프로그램을 실행시키기 위해선 JRE를 반드시 설치되어야 함 
- 자바 프로그래밍 도구는 포함되어 있지 않음 
    - 자바 프로그래밍을 하기 위해선 JDK 필요

**JDK(Java Development Kit)**

- 자바 프로그래밍 시 필요한 컴파일러 등 포함 
- 개발을 위해 필요한 도구(javac, java 등)들을 포함
- JDK를 설치하면 JRE도 같이 설치됨
- JDK = JRE + @

#### **Java SE & EE & ME**

**Java SE(Java Platform Standard Edition)**

- 데스크톱, 서버, 임베디드 시스템을 위한 표준 자바 플랫폼
- 자바 가상머신 규격 및 API 집합을 포함
- Java EE, ME는 목적에 따라 SE를 기반으로 기존의 일부를 택하거나 API를 추가하여 구성
- JDBC나 기본적인 기능이 모두 포함되어 있기 때문에 Android 개발할 때 주로 SE를 사용 

**Java EE(Java Platform Enterpise Edition)**

- 자바를 이용한 서버측 개발을 위한 플랫폼
- 기존 SE에 웹 어플리케이션 서버에서 동작하는 분산 멀티미디어를 제공하는 자바의 기능을 추가
한 서버를 위한 플랫폼
- JAVA SE의 서버측을 위한 기능을 부가하였기 때문에 SE 기능을 모두 포함

**Java ME(Java Platform Micro Edition)**

- 임베디드를 위한 자바 플랫폼
- JAVA ME 또는 J2ME 등으로 불림
- 제한된 자원을 가진 휴대전화, PDA, 세톱박스 등에서 JAVA 프로그래밍 언어를 지원

## **자바 타입**
데이터가 저장되는 메모리와 프로그램에서의 처리 방식을 명시

- 기본형 타입(프리미티브 타입), 참조형 타입(레퍼런스 타입)
    - 기본형 타입: 실제 값을 Stack 메모리에 저장
        - byte, short, int, long, float, double, char, boolean으로 총 8종류 제공    
        - 정수형, 실수형, 문자형, 논리형으로 구분
    - 참조형 타입: 실제 값의 주소를 Heap 메모리에 저장
        - array, enum, class, interface으로 총 4종류 제공
- 선언한 타입(정수형, 실수형)의 표현 범위를 벗어나면 오버플로우 또는 언더플로우가 발생
    - 오버(언더)플로우란 해당 타입의 표현 가능 최대(최소) 범위를 초과할 때 발생하는 현상
- Heap 메모리에 생성된 인스턴스 Frame에 일종의 포인터인 참조값을 가지고 있어 이를 통해 인스턴스를 핸들링 

### **자바 타입의 종류**
- 스택 메모리: 메서드 내의 지역 변수 저장소로 사용되며 메서드 호출과 함께 할당되고 메서드가 끝나면 해제
    - 속도가 빠르고 관리가 단순
- 힙 메모리: 객체와 인스턴스가 저장되는 영역으로 가비지 컬렉션의 대상
    - 메모리의 할당과 해제가 유동적이며 메모리 관리가 스택에 비해 복잡

### **자바 변수** 
다양한 정보를 저장할 수 있는 메모리를 지정하는 이름 

- 자바 컴파일러는 항상 명시적 데이터 타입(Explicit Data Type)을 선언한 변수만 처리 가능
- 정수인지 실수인지 정확히 지정해야 함
- 클래스를 변수처럼 선언 가능
    - 선언 방법: 데이터 타입을 선언하는 방법과 동일 (인스턴스: 생성되는 객체)

### **연산자**
**기본 데이터 타입**

| 연산자 종류 | 연산자 | 설명 |
|------------------|---------------------------------------|-------------------------------------------------------------------------------------------|
| 형변환 연산자 | (cast)  | 하나의 항을 형변환해 주는 연산자                                                  |
| 산술 연산자 | `+`, `-`, `*`, `/`, `%`, `+=`, `-=`, `*=`, `/=`, `%=` | 수학에서 가장 일반적으로 사용하는 연산자<br> 이항 연산자, 단항 연산자로 분류 |
| 관계 연산자 | `>`, `<`, `>=`, `<=`, `==`, `!=` | 대소관계를 나타내는 연산자 | '
| 비트 연산자 | `&`, `^`, `\|`, `<<`, `>>`, `<<=`, `>>=`, `^=`, `&=`, `\|=` | 비트 단위로 연산 <br> 주로 비트를 0과 1로 끄고 키는 연산이나 비트 단위로 전후로 이동해 결과를 내는 연산자 |
| 논리 연산자 |`&&`, `\|\|`, `&`, `^`, `\|`, `!`, `[조건] ? [true] : [false]` | 항 두 개를 비교하여 true와 false의 결과를 연산 |

- 오버플로우
    - 변수가 표현할 수 있는 최대 범위를 초과할 때 발생
    - 주로 정수형 변수(int, long)에서 발생
    - int의 최대값(약 21억) 초과 또는 최소값(-21억) 미만일 때 발생
    - 너무 큰 양수나 너무 작은 음수 할당 시 발생 
- 언더플로우
    - 부동 소수점 수에서 매우 작은 값이 정확하게 표현되지 않아 0으로 처리될 때 발생
    - 주로 부동 소수점 수(float, double)에서 발생
    - 결과가 0에 가까워질 때 발생
    - 정수형 연산에서는 발생하지 않지만 부동 소수점 연산에서 관찰됨 

**참조형 타입**<br>
기본형 타입과 달리 빈 객체를 의미하는 Null 존재 

| 구분 | 메모리의 크기 | 기본값 |
| ---- | ------------ | ------ |
| 클래스 | 4바이트 | null |
| 인터페이스 | 4바이트 | null |
| 배열 | 4바이트 | null |
| 열거 | 4바이트 | null |

### **문자열**

- 문자열 리터럴은 내부적으로 newString()을 호출해 생성한 객체
- 내용이 같은 문자열 리터럴이라면 더 이상 새로운 String 객체를 생성하지 않은 채 기존 리터럴을 공유 
- 리터럴을 공유한 인스턴스의 저장 주소값이 동일

#### **문자열 비교** 
`==`와 `!=` 연산자는 두 문자열의 내용을 비교하는 것이 아니라 동일한 객체인지 검사 <br>

**String 클래스에서 제공하는 문자열 비교 메서드**

| 메서드 | 설명 | 
|-- | -- | 
| `int compareTo(String s)` | 문자열을 사전 순으로 비교해 정수값을 반환 | 
| `int compareTolgnoreCase(String s)` | 대·소문자를 무시하고 문자열을 사전 순으로 비교 | 
| `boolean equals(String s)` | 주어진 문자열 s와 현재 문자열을 비교한 후 true/false를 반환
| `boolean equalslgnoreCase(String s)` | 주어진 문자열 s와 현재 문자열을 대·소문자 구분없이 비교한 후 true/false를 반환

**문자열 조작**

| 메서드         |설명   |
|----------------------|---------------|
| `char charAt(int index)` | index가 지정한 문자를 반환 |
| `String concat(String s)` | 주어진 문자열 s를 현재 문자열 뒤에 연결 |
| `boolean contains(String s)` | 문자열 s를 포함하는지 조사 |
| `boolean endsWith(String s)` | 끝나는 문자열이 s인지 조사 |
| `int indexOf(String s)` | 문자열 s가 나타난 위치를 반환 |
| `boolean isBlank()` | 길이가 0 혹은 공백 있으면 true 반환 (자바 11부터) |
| `boolean isEmpty()` | 길이가 0이면 true 반환 |
| `int length()` | 길이를 반환 |
| `String repeat(int c)` | index부터 시작하는 문자열의 일부를 반환 |
| `boolean startsWith(String s)` | 시작하는 문자열이 s인지 조사|
| `String substring(int index)` | index부터 시작하는 문자열의 일부를 반환 |
| `String toLowerCase()` | 모두 소문자로 변환 |
| `String toUpperCase()` | 모두 대문자로 변환 |
| `String trim()` | 앞뒤에 있는 공백을 제거한 후 반환 |

**정적 메서드**

| 정적 메서드 | 설명 | 
| -- | -- | 
| `String format()` | 주어진 포맷에 맞춘 문자열을 반환 | 
| `String join()` | 주어진 구분자와 연결한 문자열을 반환(자바 8부터) | 
| `String valueOf()` | 각종 기초 타입이나 객체를 문자열로 반환 | 

## **배열**
변수들을 연속된 집합체로 모아 놓은 것으로 동일한 이름을 사용하며 인덱스로 각 항목을 구분

### **배열의 기초**
**선언** <br>
실제는 배열 변수의 선언

```java
int[] scores; // 배열 선언 방법 1
int scores[]; // 배열 선언 방법 2
```

**배열의 선언과 생성**<br> 
실제는 배열 변수의 선언과 초기화 

**배열 원소의 접근** <br>
배열이름[인덱스];

**배열의 크기**
- 배열이 생성될 때 배열의 크기가 결정
- 배열의 length 필드가 배열의 크기를 나타냄


### **동적 배열**
- 처리할 데이터의 개수가 고정된 경우가 아니라면 정적 배열은 자원을 낭비하거나 프로그램을 다시 컴파일
- 크기가 유동적인 배열을 지원하기 위하여 ArrayList 클래스를 제공

```java
참조변수.add(데이터) // 데이터를 동적 배열에 원소로 추가
참조변수.remove(인덱스번호) // 동적 배열에서 인덱스 번호의 원소를 제거
참조변수.get(인덱스번호) // 동적 배열에서 인덱스 번호의 원소를 가져오기
참조변수.size() // 동적 배열에 포함된 원소 개수
```

### **응용**
#### **for ~ each 반복문**
- JDK 5부터 도입된 것으로 for문을 개선한 방식
- 특정 원소를 나타내기 위한 인덱스를 사용하지 않음
- 처리 순서
    1. 배열에서 다음 순서로 가져올 항목이 있으면 2단계로, 없으면 for 반복을 끝냄
    2. 배열의 항목을 변수에 저장
    3. 실행문을 처리
    4. 1단계로 이동

#### **가변 개수 인수**
- JDK 5부터는 메서드에도 데이터 타입이 같은 가변 개수(variable length)의 인수를 전달 가능
- 가변 개수 인수를 가진 메서드를 호출하면 내부적으로 배열을 생성하여 처리

#### **객체의 배열**
- 객체 배열은 객체를 참조하는 주소를 원소로 구성
- 생성자를 호출하여 객체를 생성해야 함

## **열거 타입**
### **필요성**
- 초기의 방식: 숫자로 표현
    - 문제점1: 개발자가 각 숫자의 의미를 모두 외워야 함 
    - 문제점2: 숫자만으로는 컴파일러가 무슨 의미인지 알 수 없음
    - 문제점3: 프로그램 실행 시 의미 없는 숫자로만 출력
- 개선 시도: 상수 사용
    - 장점: 개발자가 상수 이름만으로도 의미를 파악 가능
    - 단점: 컴파일러가 타입을 체크할 수 없는 등의 문제는 여전히 존재
- 해결책: 열거 타입(Java 5부터)

### **열거 타입과 응용**
서로 연관된 사건들을 모아 상수로 정의한 java.lang.Enum클래스의 자식 클래스 
- 선언
    - `enum 열거타입이름 {상수목록}`
- 응용
    - 일종의 클래스 타입인 열거 타입도 생성자, 필드 및 메서드를 가질 수 있음
    - 열거 타입 상수는 생성자에 의한 인스턴스
    - 생성자, 필드 및 메서드와 열거 타입 상수를 구분하기 위하여 다음과 같이 열거 타입 상수 뒤에 반드시 세미콜론을 추가하여 구분

## **제어문**
- 역할
    - 프로그램 내에서 똑같은 명령을 반복적으로 수행
    - 자바 프로그램이 원하는 결과를 얻기 위해서는 순차적인 흐름을 제어해야하는 경우
    - 제어 구조는 순차처리, 선택처리, 반복처리로 구분
- 종류
    - 조건문, 반복문, 기타 제어문으로 구분
        - 조건문: if, if / else, if / else if / else, 삼항연산자, switch 을 제공
        - 반복문: while, do/while, for, Enhanced for(향상된 for) 를 제공
        - 기타 제어문: continue, break 를 제공
            - 반복 제어문에서 건너뛰거나 종료를 시키기 위해 사용

## **객체지향 기초**
- 소프트웨어 객체는 현실 세계의 객체를 필드와 메서드로 모델링한 것
- 소프트웨어 객체는 상태를 필드(Field)로 정의하고, 동작을 메서드(Method)로 정의
    - 필드: 객체 내부에 선언된 변수를 의미
    - 메서드: 객체 내부에 정의된 동작

### **절차 지향 프로그래밍**
- 일련의 동작을 순서에 맞추어 단계적으로 실행하도록 명령어를 나열
- 데이터를 정의하는 방법보다는 명령어의 순서와 흐름에 중점
- 수행할 작업을 예상할 수 있어 직관적인데, 규모가 작을 때는 프로그래밍과 이해하기가 용이
- 소프트웨어는 계산 위주이므로 절차 지향 프로그래밍이 적합

### **객체 지향 프로그래밍**
- 소프트웨어의 규모가 커지면서 동작과 분리되어 전 과정에서 서로 복잡하게 얽혀 있는 데이터를 사용했기 때문에 절차 지향 프로그래밍 방식의 한계
- 절차 지향 프로그램은 추후 변경하거나 확장하기도 어려움
- 현실 세계를 객체 단위로 프로그래밍하며, 객체는 필드(데이터)와 메서드(코드)를 하나로 묶어 표현

#### **특징**
- 캡슐화(정보은닉)
    - 캡슐화는 데이터 은닉(Data Hiding)이라고도 하며, 객체지향 프로그래밍의 중요한 특징
    - 관련된 데이터와 메서드를 하나의 단위로 묶고, 구현의 세부사항을 외부로부터 감춤
    - 외부에서는 내부 동작 방식을 알 필요 없이 제공된 인터페이스만 사용
- 상속
    - 자녀가 부모 재산을 상속받아 사용하듯이 상위 객체를 상속받은 하위 객체가 상위 객체의 메서드와 필드를 사용하는 것
    - 상속은 개발된 객체를 재사용하는 방법 중 하나
- 다형성
    - 대입되는 객체에 따라서 메서드를 다르게 동작하도록 구현하는 기술
    - 실행 도중 동일한 이름의 다양한 구현체 중에서 메서드를 선택 가능
- 추상화
    - 현실 세계의 객체는 수많은 상태가 있고 다양한 동작을 하지만, 클래스에 모두 포함하기는 어렵기에 추상화(Abstraction)하는 과정이 필요
    - 추상화는 현실 세계의 객체에서 불필요한 속성을 제거하고 중요한 정보만 클래스로 표현하는 일종의 모델링 기법
    - 사람마다 추상화하는 기법이 같지 않으므로 각 개발자는 클래스를 다르게 정의 가능

## **클래스 선언과 객체 생성**
- 보통 소스 파일마다 하나의 클래스를 선언하지만, 2개 이상의 클래스를 하나의 파일로 선언 가능
- 하나의 파일에 클래스가 둘 이상 있다면 하나만 public으로 선언할 수 있고, 해당 클래스 이름은 소스 파일 이름과 동일해야 함

### **클래스 구성 요소와 멤버 접근**
- 클래스의 구성 요소 
    - 멤버: 필드, 메서드
        - 지역변수: 메서드 내부에 선언된 변수
            - 매개변수: 일종의 지역 변수
    - 생성자
    - 참고 
- 필드와 지역변수의 차이 
    - 필드는 기본값이 있지만 지역변수는 기본 값이 없어 반드시 초기화
    - 필드는 클래스 전체에서 사용할 수 있지만, 지역 변수는 선언된 블록 내부의 선언된 후에서만 사용 가능
- 필드와 메서드 접근
    - 객체참조변수.멤버
    - 클래스 내부에서 자신의 멤버에 접근하려면 참조 변수 this 혹은 참조 변수 없이 그냥 멤버 이름 그대로 사용하면 됨 

## **접근자와 설정자**
클래스 내부에 캡슐화된 멤버를 외부에서 사용할 필요 

- private으로 지정된 필드에 값을 반환하는 접근자와 값을 변경하는 설정자는 공개된 메서드
- 일반적으로 접근자는 get, 설정자는 set으로 시작하는 이름을 사용
- 필드 이름을 외부와 차단해서 독립시키기 때문에 필드 이름 변경이나 데이터 검증도 가능

## **생성자**
객체를 생성하는 시점에서 필드를 다양하게 초기화<br>

**생성자 사용**
- `클래스이름 변수 = new 클래스이름(..);`
- 생성자 이름은 클래스 이름과 동일
- 생성자의 반환 타입은 없음
- 생성자는 new 연산자와 함께 사용하며 객체를 생성할 때 호출
- 생성자도 오버로딩 가능 

**디폴트 생성자**
- 모든 클래스는 최소한 하나의 생성자가 존재
- 만약 생성자가 선언하지 않으면 컴파일러가 자동으로 디폴트 생성자를 추가 

## **정적 멤버**
자바는 static 키워드로 클래스의 필드를 공유할 수 있도록 지원

- 인스턴스 변수
    - static 키워드로 지정되지 않아 공유되지 않은 필드로 인스턴스마다 자신의 필드를 생성
    - 인스턴스 변수는 객체별로 관리
    - 객체를 생성할 때 인스턴스 변수도 객체가 소멸될 때는 자동으로 소멸
- 정적 변수 혹은 클래스 변수
    - static 키워드로 지정하여 모든 인스턴스가 공유하는 필드

## **상속**
- 자식 클래스는 부모 클래스에서 물려받은 멤버를 그대로 사용하거나 변경할 수 있고, 새로운 멤버도 추가 가능
    - 자식 클래스는 대체로 부모 클래스보다 속성이나 동적이 더 많음

**부모·자식 클래스의 관계**

| is-a(상속 관계) | has-a(소유 관계) |
|---------------- | --------------- |
| 원은 도형이다.<br>사과는 과일이다.<br>Tandem은 Bike다. | 자동차는 엔진이 있다.<br>스마트폰은 카메라가 있다.<br>컴퓨터는 마우스가 있다. |

## **메서드 오버라이딩**
물려받은 메서드를 자식 클래스에게 맞도록 수정하는 것을 의미 
- 규칙
    - 부모 클래스의 메서드와 동일한 시그너처를 사용
        - 반환 타입까지 동일해야 함
    - 부모 클래스의 메서드보다 접근 범위를 더 좁게 수정 불가
    - 추가적인 예외(Exception)가 발생할 수 있음을 나타낼 수 없음
- 오버라이딩 불가
    - private 메서드 : 부모 클래스 전용이므로 자식 클래스에 상속되지 않음
    - 정적 메서드 : 클래스 소속이므로 자식 클래스에 상속되지 않음
    - final 메서드 : final 메서드는 더 이상 수정할 수 없으므로 자식 클래스가 오버라이딩할 수 없음
- 부모 클래스의 멤버 접근
    - 자식 클래스가 메서드를 오버라이딩하면서 자식 객체는 부모 클래스의 오버라이딩된 메서드를 숨김
    - 숨겨진 메서드를 호출하려면 super 키워드 사용
        - super는 현재 객체에서 부모 클래스의 참조를 의미

| 비교 요소 | 메서드 오버라이딩 | 메서드 오버로딩 |
| --------- | ---------------- | ------------- |
| 메서드 이름 | 동일 | 동일 |
| 매개 변수 | 동일 | 다름 | 

## **패키지**
클래스 파일을 묶어서 관리하기 위한 수단으로 파일 시스템의 폴더를 이용

- 패키지에 의한 장점 
    - 패키지마다 별도의 이름 공간(Namespace)이 생기기 때문에 클래스 이름의 유일성을 보장
    - 클래스를 패키지 단위로도 제어할 수 있기 때문에 좀 더 세밀하게 접근 제어 
- 대표적인 패키지
    - java.lang 패키지: import 문을 선언하지 않아도 자동으로 임포트되는 자바의 기본 클래스를 모아둔 것 
    - java.awt 패키지: 그래픽 프로그래밍에 관련된 클래스를 모아둔 것
    - java.io 패키지: 입출력과 관련된 클래스를 모아둔 것 
- 패키지 선언
    - 주석문을 제외하고 반드시 첫 라인에 위치
    - 패키지 이름은 모두 소문자로 명명하는 것이 관례
        - 일반적으로 패키지 이름이 중복되지 않도록 회사의 도메인 이름을 역순으로 사용
- 패키지 사용
    - 다른 패키지에 있는 공개된 클래스를 사용하려면 패키지 경로를 컴파일러에게 알려줘야 함 
- import문
    - 패키지의 경로를 미리 컴파일러에게 알려주는 문장
    - import문은 소스 파일에서 package문과 첫번째 클래스 선언부 사이에 위치

## **접근 지정자의 접근 범위**

| 접근 지정자 | 동일 클래스 | 동일 패키지 | 자식 클래스 | 다른 패키지 | 
| --------- | -------- | ----------- | ---------| ----------|
| public | O | O | O | O |
| protected | O | O | O | X |
| 없음 | O | O | X | X |
| private | O | X | X | X |

**접근 지정자 사용 시 주의사항**
- private 멤버는 자식 클래스에 상속되지 않음
- 클래스 멤버는 어떤 접근 지정자로도 지정 가능하지만, 클래스는 protected와 private으로 지정 불가능
- 메서드를 오버라이딩할 때 부모 클래스의 메서드보다 가시성을 더 좁게 할 수는 없음

## **Final 클래스와 메서드**
- Final 클래스
    - 더 이상 상속될 수 없는 클래스
    - 대표적인 final 클래스로는 String 클래스 
- final 메서드 
    - final클래스는 클래스 내부의 모든 메서드를 오버라이딩 불가능
    - 특정 메서드만 오버라이딩하지 않도록 하려면 final 메서드로 선언

## **타입 변환과 다형성**
- 객체의 타입 변환
    - 참조 타입 데이터도 기초 타입 데이터처럼 타입 변환 가능
    - 상속 관계일 경우만 타입 변환 가능
    - 기초 타입처럼 자동 타입 변환과 강제 타입 변환이 존재

## **추상 메서드 & 추상 클래스**
- 추상 메서드 
    - 메서드 본체를 완성하지 못한 메서드
    - 무엇을 할지는 선언할 수 있지만, 어떻게 할지는 정의할 수 없음
- 추상 클래스
    - 보통 하나 이상의 추상 메서드를 포함하지만 없을 수도 있음
    - 주로 상속 계층에서 자식 멤버의 이름을 통일하기 위하여 사용

## **인터페이스**
- 대표적인 인터페이스 
    - java.lang 패키지: CharSequence, Comparable, Runnable 등
    - java.util 패키지: Collection, Comparator, List 등
- 인터페이스의 구조 
    - 인터페이스 멤버에 명시된 public, static, final, abstract 키워드는 생략 가능
    - 생략한 키워드는 컴파일 과정에서 자동으로 추가
    - 인터페이스 파일 확장자도 java
    - 컴파일하면 확장자가 class인 파일을 생성
- 인터페이스에 의한 장점 
    - 인터페이스만 준수하면 통합에 신경 쓰지 않고 다양한 형태로 새로운 클래스를 개발 가능
    - 클래스의 다중 상속을 지원하지 않지만, 인터페이스로 다중 상속 효과를 간접적으로 얻을 수 있음

### **인터페이스와 추상 클래스의 차이**

| 분류 | 인터페이스 | 추상 클래스 |
| --| -- | -- | 
| 구현 메서드 | 포함 불가(단, 디폴트 메서드와 정적 메서드는 예외) | 포함 가능 | 
| 인스턴스 변수 | 포함 불가능 | 포함 가능 | 
| 다중 상속 | 가능 | 불가능 | 
| 디폴트 메서드 | 선언 가능 | 선언 불가능 | 
| 생성자와 main() | 선언 불가능 | 선언 가능 | 
| 상속에서의 부모 | 인터페이스 | 인터페이스, 추상 클래스 | 
| 접근 범위 | 모든 멤버를 공개 | 추상 메서드를 최소한 자식에게 공개 | 

### **인터페이스와 다형성**
- 인터페이스 타입 
    - 인터페이스도 클래스처럼 하나의 타입이므로 변수를 인터페이스 타입으로 선언 가능
    - 인터페이스의 구현 클래스는 그 인터페이스의 자식 타입
    - 인터페이스 타입 변수가 구현 객체를 참조한다면 강제 타입 변환 가능

## **제네릭**
- 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법
- 데이터 타입(Data Type)을 일반화(Generalize)하는 것을 의미
- 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시 미리 저장하는 방법
- 제네릭 사용시에 클래스나 메소드 내부에 사용되는 객체의 타입 안정성 향상
-  반환 값에 대한 타입 변환 및 타입 검사에 들어가는 비용 절감

### **제너릭 타입**

| 제너릭 타입 | 설명 |
| -- | --|
| T | 타입(Type)을 나타냄<br>일반적으로 클래스나 인터페이스에서 타입 매개변수로 사용 | 
| E | 요소(Element)를 나타냄 <br> 주로 컬렉션에서 사용되는 항목의 타입을 지정할 때 사용 |
| K | 키(Key)를 나타냄 <br> 맵(Map) 같은 자료구조에서 키의 타입을 지정할 때 사용|
| V | 값(Value)을 나타냄 <br> 맵(Map)에서 값의 타입을 지정할 때 사용 | 
| N | 숫자(Number)를 나타냄 <br> 숫자 타입의 제한을 두고 싶을 때 사용 | 

### **사용 방법**
- 제너릭 타입은 타입을 파라미터로 가지는 클래스와 인터페이스 
- 제너릭 타입은 클래스 또는 인터페이스 이름 뒤에 <>부호가 붙고 사이에 타입 파라미터가 위치 

### **제너릭 클래스** 
- 클래스를 설계할 때 구체적인 타입을 명시하지 않고 타입 파라미터로 넣어두었다가 실제 설계한 클래스가 사용되어질 때
- ExClassGeneric<String> exGeneric = new ExClassGeneric<>(); 형태
    - 구체적인 타입을 지정하면서 사용하면 타입 변환을 최소화 시킬 수 있음

### **제네릭 메소드**
- 리턴 타입을 정의하기 전에 제네릭 타입에 대한 정의를 반드시 명시
- 제네릭 클래스가 아닌 일반 클래스 내부에도 제네릭 메서드를 정의
- 클래스에 지정된 타입 파라미터와 제네릭 메서드에 정의된 타입 파라미터는 관계 없음
- 즉, 제네릭 클래스에 `<T>` 를 사용하고, 같은 클래스의 제네릭 메서드에도 `<T>` 로 같은 이름을 가진 타입 파라미터를 사용하더라도 둘은 전혀 관계 없음

### **제네릭 와일드 카드**
와일드카드 타입에는 총 세가지의 형태가 있으며 물음표(?)라는 키워드로 표현

- 제네릭 타입<?> : 타입 파라미터를 대치하는 것으로 모든 클래스나 인터페이스타입 가능
- 제네릭 타입<? extends 상위타입> : 와일드카드의 범위를 특정 객체의 하위 클래스만 가능
- 제네릭 타입<? super 하위타입> : 와일드카드의 범위를 특정 객체의 상위 클래스 가능

## **예외(Exception)**
- 예외(Exception)
    - 사용자의 잘못된 조작 또는 개발자의 잘못된 코딩으로 인해 발생하는 프로그램 오류 
    - 예외 처리 프로그램 통해 정상 실행상태 유지 가능
    - 예외 발생 가능성이 높은 코드 컴파일할 때 예외 처리 유무 확인
- 일반 예외(Checked Exception)
    - 컴파일할 때 발견되는 예외
    - 반드시 예외 처리를 해야 프로그램이 실행
    
    | 예외 클래스 | 설명 | 
    | -- | --| 
    |IOException|입력 및 출력 작업 실패 또는 인터럽트 시 발생하는 예외|
    |FileNotFoundException|파일이 없을 때 발생하는 예외|
    |ParseException|문자열을 파싱하는 도중 문제가 발생했을 때 발생하는 예외|
    |ClassNotFoundException|요청한 클래스를 찾을 수 없을 때 발생하는 예외|
    |SQLException|데이터베이스 접근 오류나 다른 오류들 때문에 발생하는 예외|
    |MalformedURLException|잘못된 형식의 URL을 지정할 경우 발생하는 예외|
    |InterruptedException|쓰레드가 작업 중 인터럽트될 때 발생하는 예외 |
    |NoSuchMethodException|요청한 메소드를 찾을 수 없을 때 발생하는 예외|
    |NoSuchFieldException|요청한 필드를 찾을 수 없을 때 발생하는 예외 |

- 실행 예외(runtime exception, Unchecked Exception)
    - 프로그램 실행 중에 발생하는 예외
    - 컴파일 할 때는 문제가 없다가 실행하면서 발생

    | 예외 종류 | 설명 | 
    | -- | -- | 
    | NullPointerException | 객체 참조가 null인 경우에 접근할 때 발생 |
    | ArrayIndexOutOfBoundsException | 배열의 인덱스가 유효 범위를 벗어났을 때 발생 |
    | ArithmeticException | 산술 연산 예외, 예를 들어 0으로 나눌 때 발생 |
    | NumberFormatException | 문자열을 숫자로 변환하려고 할 때 형식에 맞지 않는 경우 발생 |  
    | ClassCastException | 객체를 잘못된 타입으로 캐스팅하려고 할 때 발생 |
    | IllegalArgumentException | 메서드에 부적합한 인자를 전달했을 때 발생 |
    | IllegalStateException | 객체가 메서드 호출에 적절하지 않은 상태일 때 발생 |
    | IndexOutOfBoundsException | 인덱스가 범위를 벗어났을 때, 예를 들어 문자열의 인덱스 접근 시 발생 |
    | UnsupportedOperationException | 지원되지 않는 연산을 요청할 때 발생 |

### **예외 처리 방법** 
- try-catch 블록
    - try-catch 블록을 사용하는 것은 가장 일반적인 예외 처리 방법
    - 코드 블록을 try로 감싸 예외가 발생할 수 있는 부분을 명시하고, catch 블록에서 해당 예외를 처리
- throws 키워드
    - 메서드가 예외를 직접 처리하지 않고 호출한 쪽으로 예외를 던짐
    - 메서드 선언부에 throws 키워드를 사용하여 해당 메서드에서 처리하지 않고 던져질 예외를 명시
    - 방법은 주로 체크 예외를 처리할 때 사용
- finally 블록
    - finally 블록은 예외 발생 여부와 관계없이 실행되는 코드 블록
    - 주로 리소스를 해제하거나 정리하는 코드를 포함하는 데 사용
    - try 또는 try-catch 블록과 함께 사용할 수 있음

## **자료구조**
하나의 데이터 타입으로 여러 데이터를 처리하기 위해 만들어진 개념

### **배열(Array)**
- 배열
    - 전통적으로 기본이 되는 자료구조
    - 데이터를 순차적으로 저장해 0부터 시작하는 인덱스를 통해 접근
    - 순차적으로 사용하는 단순한 문자나 숫자 등으로 이루어진 집합형 데이터 처리 사용시 유용
    - 자바에서 배열은 기본적인 자료형이나, 구조에 따른 제약과 사용의 불편함 등으로 List를 많이 사용
- 특징 
    - 일반적으로 배열은 선언할 때 크기가 고정
    - 데이터를 순차적으로만 접근할 수 있어 위치를 모르는 경우 효율이 떨어짐
    - 배열에 들어가는 데이터는 동일한 자료형만 가능
    - 배열 중간에 값을 추가하려면 기존 데이터를 모두 이동시켜야 함

### **리스트(List)**
- 리스트
    - 배열과 유사한 순차적인 자료구조 제공
    - 데이터를 접근하기 위해서 인덱스를 사용해야 하는 점은 동일
    - 배열의 문제점을 보완한 자료 구조
- 특징
    - 데이터 크기가 고정되지 않음
    - 데이터를 다루기 위한 여러 방법을 제공
    - 리스트에 들어가는 데이터는 서로 다른 자료형으로 사용 가능
    - 배열 중간에 값을 추가하거나 삭제하기 쉬움
    - 특정 데이터가 포함되어 있는지 확인은 가능하나 검색을 위해서는 별도 구현이 필요

### **맵(Map)**
- 맵 
    - 데이터를 키와 값의 쌍으로 저장하는 자료구조
    - 데이터를 접근하기 위해서 키를 사용하여 접근
- 특징
    - 키는 중복된 값을 입력 불가하나 값을 중복 허용
    - 데이터를 저장할 때 해당 데이터를 찾기 위한 키를 부여
    - 사용관점에서 Array, List 보다 데이터를 검색시 효율적으로 검색 가능

## **컬렉션**
- 연관 있는 자료들을 모아놓은 자료구조
- 자료구조는 데이터를 효율적으로 저장, 관리, 검색할 수 있도록 만들어 놓은 것
- 자바에서 데이터를 유용하게 담기 위해 만들어둔 인터페이스
    - 인터페이스이기 때문에 사용자들이 사용하기 위해서는 인터페이스를 상속받아 정의해 둘 필요가 있었고, 정의된 클래스들을 자바에서 제공하여 언제든지 사용 가능

    | 인터페이스 | 대표적인 구현 클래스 | 설명 |
    | --|--|--|
    | Set<E> | HashSet<br>LinkedHashSet<br>TreeSe | 순서를 유지하지 않는 데이터 집합으로 중복을 허용하지 않음 |
    | List<E> |LinkedList<br>Stack<br>Vector<br>ArrayList|순서가 있는 데이터 집합으로 중복을 허용|
    | Queue<E> |LinkedList<br>PriorityQueue|순서가 있는 데이터 집합으로 중복을 허용
데이터 접근시 순차적으로 접근<br>(선입선출 -FIFO 구조)|
    | Map<K,V>|Hashtable<br>HashMap<br>LinkedHashMap<br>SortedMap|키와 값으로 이루어진 데이터 집합으로 키는 중복을 허용하지 않고, 값은 중복을 허용|

- List, Set, Queue, Map 등이 존재 

### **컬렉션 종류의 특징**
- 셋(Set) 특징 
    - 저장된 요소들이 순서가 없고, 데이터를 중복으로 저장 불가
    - 인덱스를 사용하지 않으며, iterator를 사용하여 접근
    - 자바에서 제공되는 set 의 종류로는 HashSet, TreeSet, LinkedHashSet 등이 존재
    - 집합의 개념으로 데이터가 존재하며, 데이터 정렬시 별도의 처리가 필요

    | 메소드명 | 설명 | 
    | -- | --|
    | Set.add(object) | Set 객체에 요소를 추가 |
    | Set.remove(object) | Set 객체에 전달 된 요소를 제거 |
    | Set.clear() | Set 객체에 모든 요소 제거 |
    | Set.size() | Set 객체의 요소 총 개수 반환 |
    | Set.contains(object) | Set 객체에 요소 존재 여부 판단<br>존재 : true, 미존재 : false|
    | Set.isEmpty() | Set 객체가 요소가 비어있는지 여부 판단<br>존재 : false, 미존재 : true|
- HashSet 특징
    - 순서를 보장하지 않는 Set
    - 가장 일반적인 Set과 Hash 알고리즘을 적용한 자료구조로 가장 빠름 
- TreeSet 특징
    - Binary Search Tree 구조
    - 추가와 삭제에는 시간이 좀 더 걸리지만, 정렬 및 탐색에 성능이 좋음
    - 저장된 데이터의 값에 따라 정렬되는 구조
- LinkedHashSet 특징
    - 데이터가 들어간 순서대로 저장하는 Set
    - 해시 테이블을 사용하여 요소의 유일성을 보장
    - 연결 리스트를 사용하여 요소의 순서를 기록
- 리스트(List) 특징
    - 저장된 요소들이 순서가 있고 데이터 중복이 가능하고, 인덱스에 의해서 정렬
    - 컬렉션(Collection) 인터페이스 중 하나이며, ArrayList 와 LinkedList 두 종류로 존재
    - 초기 크기를 지정하지 않아도 되며, 크기 조절이 가능
    - 삭제 시 데이터 공간을 지움

    | 메소드명 | 설명 | 
    | -- | -- | 
    | List.add(value) | 데이터 추가<br>기존 데이터가 존재하는 인덱스 다음 인덱스에 value 저장 | 
    | List.add(index, value) | 중간 데이터 삽입<br>index : 중간에 넣을 인덱스(배열 인덱스)<br>value : 중간에 넣을 값<br>중간에 값을 넣을 경우 이후 값들은 index 값이 1씩 증가 | 
    | List.set(index, value) | 중간 데이터 삽입과 비슷하게 index는 치환할 값 자리에 인덱스이고, value는 치환할 자리에 값 | 
    | List.remove(index) | 인덱스 위치에 있는 값을 삭제 | 
    | List.get(index)  | 인덱스 위치에 있는 값 반환 | 
    | List.size()  | 리스트에 크기(길이) 반환 | 
- ArrayList 특징
    - 데이터를 순차적으로 추가
    - 배열과 유사하나, 크기를 지정하지 않아도 데이터 추가시 크기 증가
-  LinkedList 특징
    - 데이터 간 링크되어 저장
    - 하나의 데이터에는 이전 데이터와 다음 데이터의 주소들이 서로 연결
    - 리스트 중간에 데이터 추가시 이전 주소의 연결을 끊고 새로 연결
    - 자바 Linked List는 더블 링크드 리스트 데이터 구조를 사용
    - 요소의 삽입과 삭제가 빈번하게 일어나는 경우 유용
- 큐(Queue) 특징
    - FIFO(First-In-First-Out, 선입선출) 원칙을 따라 요소를 관리
    - 첫 번째로 추가된 요소가 첫 번째로 제거
    - LinkedList, PriorityQueue, ArrayDeque
    - 데이터의 순차적 처리를 효율적으로 할 수 있음
    - 멀티 스레딩 환경에서도 안전하게 사용할 수 있는 동기화된 큐 제공

    | 메소드명 | 설명 |
    | -- | -- | 
    | Queue.add(value) | 큐의 맨 뒤에 값 추가 | 
    | Queue.element() | 큐의 맨 앞 값 반환<br>큐가 비어 있을 경우 NoSuchElementException 에러 발생| 
    | Queue.peek() | 큐의 맨 앞 값 반환, 큐가 비어 있을 경우 null 반환| 
    | Queue.poll() | 큐의 맨 앞 값 반환 후 삭제, 큐가 비어 있을 경우 null 반환 | 
    | Queue.remove() | 큐의 맨 앞 값 반환 후 삭제 <br>큐가 비어 있을 경우 NoSuchElementException 에러 발생| 
    | Queue.clear() | 큐 전체 데이터 비우기 | 
- 맵(Map) 특징
    - 키(key)와 값(value) 쌍의 형태로 이루어져 있으며, 보통 검색을 목적으로 사용
    - 데이터의 순서가 없으며, 중간 삽입도 없음
    - 키(key)는 중복이 불가 하나, 값(value)은 중복 가능
    - 키(key)는 set에 저장

    | 메소드명 | 설명 |
    | -- | -- | 
    | Map.put(key, value) | 키(key)와 값(value)으로 이루어진 데이터 추가 | 
    | Map.get(key) | 키(key) 에 저장된 데이터 반환 |  
    | Map.remove(key)| 키(key) 데이터 삭제 | 
    | Map.size() | Map 데이터의 사이즈 반환 | 
    | Map.containsKey(key) | Map 데이터에 키(key) 존재 여부 판단<br>존재 : true, 미존재 : false| 
    | Map.containsValue(value) | Map 데이터에 값(value) 존재 여부 판단<br>존재 : true, 미존재 : false| 
- HashMap 특징
    - 동기화를 지원하지 않아 멀티 스레드 환경에서 데이터 일관성 보장 안됨(단일 스레드 개발 환경에 사용 추천)
    - 키(key) 와 값(value)에 null 데이터로 추가 가능
    - 중복된 키(key) 로 값(value) 저장시 신규 데이터 대체
- HashTable 특징
    - 동기화를 지원하며, 멀티 스레드 환경에서 데이터 일관성 보장
    - 키(key) 와 값(value)에 null 데이터로 추가 불가
    - 중복된 키(key) 로 값(value) 저장시 이전 데이터로 유지